use crate::backend::var;
use crate::lexer::{self, Span, TokenType};
use core::str;
use std::collections::HashMap;
use std::collections::btree_map::Values;
use std::fs::File;
use std::io::Write;
use std::path::{self, Path};
use std::process::exit;
use std::str::FromStr;

use colored::Colorize;
pub use serde::ser::SerializeTupleVariant;

use crate::parser::{AstNode, FunctionArg, Parser, Spanned};

use super::bundle::Bundle;
use super::compile_error::{CompileError, ErrLevel};
use super::context::Context;
use super::function::Function;
use super::ttype::Type;
use super::type_table::TTable;
use super::var::Var;
use super::var_table::VTable;

#[derive(Debug, Clone)]
struct FResult {
    stream: String,
    type_hint: Type,
}
#[derive(Debug, Clone)]
pub(crate) struct FieldLayout {
    ty: Type,
}
#[derive(Debug, Clone)]
pub struct BlockLayout {
    pub name: Type,
    pub feilds: HashMap<String, FieldLayout>,
    pub methods: Vec<Function>,
    pub file: String,
}
#[derive(Debug, Clone)]
enum RefStyle {
    DEREF,
    REF,
    MOVE,
    COPY,
}
#[derive(Debug, Clone)]
struct ExprResult {
    stream: String,
    is_ref: bool,
    is_moved: bool,
    is_deref: bool,
    refed_var: Option<String>,
    moved_from: Option<String>,
    type_hint: Box<Type>,
    var: Option<String>,
}

#[derive(Debug, Clone)]
pub enum Section {
    TEXT,
    FUNC,
    Header,
}

#[derive(Debug, PartialEq, Eq)]
pub enum BodyType {
    GENERIC,
    NORMAL,
    LOOP,
    IF,
}

pub struct Generator {
    cur_body_type: BodyType,
    inputpath: String,
    pub source: Vec<Spanned<AstNode>>,
    outfilepath: String,
    bss: String,
    data: String,
    pub text: String,
    func: String,
    header: String,
    cur_offset: u16,
    immediate_counter: u8,
    func_table: Vec<Function>,
    gfunc_table: Vec<Function>,
    var_table: VTable,
    current_context: Context,
    cur_section: Section,
    track_rsp: bool,
    rsp_alloc: u16,
    outfilename: String,
    source_code: String,
    has_error: bool,
    types: TTable,
    global_context: Context,
    bundles: Vec<Bundle>,
    is_included: bool,
    errorbox: Vec<CompileError>,
    current_file: String,
    bundled: Vec<String>,
    generics: Vec<Generic>,
}
#[derive(Debug, Clone)]
pub struct Generic {
    name: Type,
    generics: Vec<Type>,
}
impl Generator {
    pub fn new(
        source: Vec<Spanned<AstNode>>,
        path: &str,
        input: String,
        is_included: bool,
        inputpath: String,
        current_file: String,
    ) -> Self {
        /* global context for global variables */
        let global_context = Context::new("global".into(), None);
        /* base types: int, str, u8, ... , i64 */
        let mut base = TTable::new();
        Generator {
            cur_body_type: BodyType::NORMAL,
            source,
            outfilepath: path.to_string(),
            bss: String::new(),
            data: String::new(),
            text: String::new(),
            func: String::new(),
            header: String::new(),
            cur_offset: 1,
            immediate_counter: 0,
            func_table: Vec::new(),
            var_table: VTable::new(),
            cur_section: Section::TEXT,
            track_rsp: false,
            rsp_alloc: 0,
            errorbox: vec![],
            outfilename: std::path::Path::new(path)
                .file_name()
                .unwrap()
                .to_str()
                .unwrap()
                .to_string(),
            source_code: input.clone(),
            has_error: false,
            types: base,
            global_context: global_context.clone(),
            current_context: global_context,
            bundles: Vec::new(),
            is_included,
            inputpath,
            current_file,
            bundled: vec![],
            generics: vec![],
            gfunc_table: vec![],
        }
    }
    pub fn change_scope(&mut self, name: &str) {
        let context = Context::new(
            name.to_string(),
            Some(Box::new(self.current_context.clone())),
        );
        self.current_context = context;
    }
    pub fn exit_scope(&mut self) {
        let mut context = self.current_context.clone();
        let prev_context = context.get_parent();
        if !matches!(prev_context, None) {
            self.current_context = prev_context.unwrap();
            return;
        }
        self.current_context = self.global_context.clone();
    }
    pub fn init(&mut self) {
        self.cur_section = Section::Header;
        if self.is_included {
            self.emit("#pragma once\n");
        }
        self.emit("\n#include \"/home/dry/Documents/Eggo/jaguar/std/claw.h\"");
        self.cur_section = Section::TEXT;
    }
    pub fn generate(&mut self, source: Vec<Spanned<AstNode>>) {
        for node in source.clone() {
            match node.clone().node {
                AstNode::LetStmt {
                    name,
                    type_hint,
                    value,
                } => {
                    if type_hint.clone() == Type::NoType {
                        self.consume(CompileError::new(
                            format!("Cannot assign to type void"),
                            None,
                            value.clone().span,
                            ErrLevel::ERROR,
                        ));
                        self.flush();
                    }
                    if let Some(v) = self.lookup_variable(&name).cloned() {
                        self.consume(CompileError::new(
                            format!("Redefinition of {name}"),
                            None,
                            node.clone().span,
                            ErrLevel::ERROR,
                        ));
                        self.consume(CompileError::new(
                            format!("Previously defined here"),
                            None,
                            v.definition,
                            ErrLevel::WARNING,
                        ));
                        self.flush();
                    }
                    let l = self.get_layout(type_hint.clone());
                    if !l.is_some() && type_hint != Type::Any {
                        if let Type::Generic { base, generics } = type_hint.clone() {
                            let t = self.generics.iter().find(|p| p.name == type_hint);
                            let sv = self.cur_section.clone();
                            self.cur_section = Section::Header;
                            let mut hd = String::new();
                            hd += &format!("\nGENERIC_BLOCK_{}(", base.to_str().to_uppercase());
                            for (i, g) in generics.iter().enumerate() {
                                hd += &format!("{}", g.to_str());
                                if i != generics.len() - 1 {
                                    hd += ","
                                }
                            }
                            hd += ");\n";
                            self.emit(&hd);
                            self.cur_section = sv;
                        } else {
                            self.consume(CompileError::new(
                                format!("Not a Type, '{}'", type_hint.debug()),
                                None,
                                node.clone().span,
                                ErrLevel::ERROR,
                            ));
                            self.flush();
                        }
                    }
                    let mut temp_stream: String = String::new();
                    let out = self.gen_expr(value.clone(), type_hint.clone(), RefStyle::COPY);
                    if *out.type_hint.clone() == Type::NoType {
                        self.consume(CompileError::new(
                            format!("Expression does not return a value"),
                            None,
                            value.clone().span,
                            ErrLevel::ERROR,
                        ));
                        self.flush();
                    }
                    if !self.type_match(type_hint.clone(), *out.type_hint.clone()) {
                        self.consume(CompileError::new(
                            format!(
                                "Type Mismatch. '{}' expected '{}' but got '{}' instead",
                                name.clone(),
                                type_hint.clone().debug(),
                                out.type_hint.clone().debug(),
                            ),
                            None,
                            value.clone().span,
                            ErrLevel::ERROR,
                        ));
                        self.flush();
                    }
                    temp_stream += out.stream.as_str();
                    let mut new_var = var::Var {
                        name: name.clone(),
                        offset: self.cur_offset,
                        type_hint: type_hint.clone(),
                        is_moved: false,
                        is_ref: out.is_ref
                            || if let Type::PTR(v) = type_hint.clone() {
                                true
                            } else {
                                false
                            },
                        references: None,
                        moved_to: None,
                        definition: node.clone().span,
                    };
                    if type_hint == Type::Any {
                        new_var.type_hint = *out.type_hint.clone();
                    }
                    // ToDo: Implement Functionality => VTable
                    if let Some(ref_name) = out.refed_var {
                        new_var.references = Some(Box::new(
                            self.lookup_variable(&ref_name.as_str()).unwrap().clone(),
                        ));
                        self.lookup_variable(&ref_name.as_str()).unwrap().is_ref = true;
                    }
                    if let Some(from_name) = out.moved_from {
                        self.lookup_variable(&from_name.as_str()).unwrap().is_moved = true;
                        self.lookup_variable(&from_name.as_str()).unwrap().moved_to =
                            Some(Box::new(new_var.clone()));
                    }
                    if self.track_rsp {
                        self.rsp_alloc += 1;
                    }
                    if self.cur_body_type != BodyType::GENERIC {
                        self.emit(
                            format!(
                                "\n\t{} {} = {};",
                                new_var.clone().type_hint.to_str(),
                                name,
                                out.stream
                            )
                            .as_str(),
                        );
                    } else {
                        self.emit(
                            format!(
                                "\n\t{} {} = {};",
                                new_var.clone().type_hint.genimpl(),
                                name,
                                out.stream
                            )
                            .as_str(),
                        );
                    }
                    self.current_context.add(new_var);
                    self.cur_offset += 1;
                }
                AstNode::DeRefExpr { expr } => {
                    let s = self.gen_expr(Box::new(node), Type::Any, RefStyle::DEREF);
                    self.emit(&format!("\n\t{};", s.stream));
                }
                AstNode::RefExpr { expr } => {
                    let s = self.gen_expr(Box::new(node), Type::Any, RefStyle::REF);
                    self.emit(&format!("\n\t{};", s.stream));
                }
                AstNode::NameSpace { alias, body } => {
                    let sc = self.current_context.clone();
                    let st = self.types.clone();
                    let sf = self.func_table.clone();
                    let sb = self.bundles.clone();
                    self.current_context = Context::new(alias.clone(), Some(Box::new(sc.clone())));
                    self.types = TTable::new();
                    self.bundles = vec![];
                    self.generate(match body.clone().node {
                        AstNode::Program(k) => k.clone(),
                        _ => {
                            self.consume(CompileError::new(
                                "Fatal Error".into(),
                                None,
                                body.clone().span,
                                ErrLevel::ERROR,
                            ));
                            exit(1); /* should not reach here */
                        }
                    });
                    let bundle = Bundle::new(
                        alias,
                        self.current_context.get_content(),
                        self.func_table.clone(),
                        self.types.clone(),
                        self.bundles.clone(),
                        self.outfilepath.clone(),
                    );
                    self.current_context = sc;
                    self.types = st;
                    self.func_table = sf;
                    self.bundles = sb;
                    self.bundles.push(bundle);
                }
                AstNode::BundleAccess { base, field } => {
                    let out = self.gen_expr(Box::new(node), Type::Any, RefStyle::COPY);
                    self.emit("\n\t");
                    self.emit(&out.clone().stream);
                    self.emit(";");
                }
                AstNode::BundleStmt { path, alias } => {
                    /* append var:path to the parent path of the main file */
                    let global = std::env::current_dir()
                        .unwrap()
                        .to_str()
                        .unwrap()
                        .to_string();
                    let p_import_path = std::path::Path::new(&self.outfilepath)
                        .parent()
                        .unwrap()
                        .to_str()
                        .unwrap()
                        .to_string();
                    let import_path = format!("{}/{}/{}", global, p_import_path, path);
                    let cwd = std::env::current_dir().unwrap();
                    if !std::path::Path::exists(Path::new(import_path.as_str())) {
                        println!("importing from {import_path}");
                        println!("outpath = : {}", self.outfilepath);
                        println!("pdir = {p_import_path}");
                        self.consume(CompileError::new(
                            format!("Could not resolve {}", path),
                            Some("Try Confirming Bundle Path or alias".to_string()),
                            node.span,
                            ErrLevel::ERROR,
                        ));
                        self.flush();
                        exit(1);
                    }
                    let p_dir = std::path::Path::new(&import_path).parent().unwrap();
                    let source = std::fs::read_to_string(import_path.clone()).unwrap();
                    let ext = path.split_at(path.len() - 3).1;
                    let mut output = import_path.clone();
                    if ext == ".jr" {
                        output = path.clone().split_at(path.len() - 3).0.to_string();
                    }
                    let mut tokenizer = lexer::Tokenizer::new(&source);
                    let mut tokens = Vec::new();
                    loop {
                        let tok = tokenizer.next_token();
                        if let TokenType::Comment(_) = tok.kind {
                            continue;
                        }
                        tokens.push(tok.clone());
                        if tok.kind == lexer::TokenType::EOF {
                            break;
                        }
                    }
                    let mut parser = Parser::new(tokens, source.clone());
                    let final_output = format!("{}.h", import_path);
                    output = format!("{}/{}", cwd.to_str().unwrap(), final_output);
                    let mut found = false;
                    for mut b in self.bundles.clone() {
                        if b.refuse_dup(output.clone()).is_some() {
                            let mut nb = b.refuse_dup(output.clone()).unwrap();
                            nb.name = alias.clone();
                            self.bundles.push(nb);
                            found = true;
                        }
                    }
                    if found {
                        continue;
                    }
                    match parser.parse_program() {
                        program => {
                            let mut cgen = Generator::new(
                                program,
                                &final_output,
                                source,
                                true,
                                path.clone(),
                                std::fs::canonicalize(path::Path::new(&import_path))
                                    .ok()
                                    .map(|p| p.to_string_lossy().to_string())
                                    .unwrap(),
                            );
                            cgen.init();
                            cgen.generate(cgen.source.clone());
                            cgen.rest();
                            self.bundled.append(&mut cgen.bundled.clone());
                            // self.bundles.append(&mut cgen.bundles.clone());
                            let mut new_bundle = Bundle::new(
                                alias.clone(),
                                cgen.var_table,
                                cgen.func_table,
                                cgen.types,
                                cgen.bundles,
                                final_output.clone(),
                            );
                            for f in &mut new_bundle.functions {
                                for arg in &mut f.args {
                                    if !is_builtin(arg.type_hint.clone()) {
                                        arg.type_hint = Type::BundledType {
                                            bundle: alias.clone(),
                                            ty: Box::new(arg.type_hint.clone()),
                                        }
                                    }
                                }
                                if !is_builtin(f.ty.clone()) {
                                    f.ty = Type::BundledType {
                                        bundle: alias.clone(),
                                        ty: Box::new(f.ty.clone()),
                                    };
                                }
                            }
                            new_bundle.types.wrap(alias.clone());
                            self.bundles.push(new_bundle);
                            self.generics.append(&mut cgen.generics);
                            // exit(1);
                            let sv = self.cur_section.clone();
                            self.cur_section = Section::Header;
                            println!("final output: {final_output}");
                            self.emit(format!("\n#include \"{final_output}\"").as_str());
                            self.cur_section = sv;
                            self.bundled.push(output);
                        }
                    };
                }
                AstNode::MemberAccess { base: _, field: _ } => {
                    let out = self.gen_expr(Box::new(node), Type::Any, RefStyle::COPY);
                    self.emit("\n\t");
                    self.emit(&out.stream);
                    self.emit(";");
                }

                AstNode::BlockStmt {
                    name,
                    fields,
                    meths,
                } => {
                    let layout: BlockLayout;
                    let mut b_fields: HashMap<String, FieldLayout> = HashMap::new();
                    let save = self.cur_section.clone();
                    self.cur_section = Section::Header;
                    // self.emit(format!("\njaguar_deftype({});", name.clone()).as_str());
                    self.emit(format!("\ntypedef struct {name} {{\n").as_str());

                    for (_i, field) in fields.clone().iter().enumerate() {
                        if let AstNode::Feilds {
                            name: fname,
                            type_hint,
                        } = field.node.clone()
                        {
                            if self.verifyType(type_hint.clone()) != None {
                                self.emit(format!("\n\t{} {fname};", type_hint.to_str()).as_str());
                                b_fields.insert(fname.clone(), FieldLayout { ty: type_hint });
                            } else {
                                self.consume(CompileError::new(
                                    format!("Not a type, {}", type_hint.debug()),
                                    None,
                                    field.span.clone(),
                                    ErrLevel::ERROR,
                                ));
                                self.flush();
                            }
                        }
                    }
                    layout = BlockLayout {
                        name: Type::Custom(name.clone()),
                        feilds: b_fields.clone(),
                        methods: Vec::new(),
                        file: self.current_file.clone(),
                    };
                    self.types.add_type(Type::Custom(name.clone()), layout);
                    self.emit(format!("}} {name};").as_str());
                    for m in meths.clone() {
                        if let Spanned {
                            node:
                                AstNode::FnStmt {
                                    body,
                                    args,
                                    name: fname,
                                    ret_type,
                                    returns,
                                    return_val,
                                    vardaic,
                                    mangled_name,
                                },
                            span,
                        } = m.clone().unwrap()
                        {
                            let targ_type = Type::Custom(name.clone());
                            let layout = self.get_layout(targ_type.clone());
                            if matches!(layout, None) {
                                println!(
                                    "ToDo Err system: Not a type {}",
                                    targ_type.debug().clone()
                                );
                                exit(1);
                            }
                            match layout
                                .as_ref()
                                .unwrap()
                                .clone()
                                .methods
                                .clone()
                                .iter()
                                .find(|m| m.get_name() == fname.clone())
                            {
                                Some(plug) => {
                                    println!(
                                        "ToDo Err system: Plugin {} already exsist for type {}",
                                        fname.clone(),
                                        targ_type.debug().clone()
                                    );
                                    exit(1);
                                }
                                None => (),
                            }
                            let mut context = Context::new(
                                name.clone(),
                                Some(Box::new(self.current_context.clone())),
                            );
                            self.emit(&format!(
                                "\nextern inline {} {}_{}(",
                                ret_type.clone().to_str(),
                                targ_type.to_str(),
                                fname.clone()
                            ));
                            for (i, a) in args.clone().iter_mut().enumerate() {
                                let mut modif = "";
                                if a.name == "self" {
                                    modif = "*";
                                    a.type_hint = targ_type.clone();
                                }
                                self.emit(&format!(
                                    "{}{modif} {}",
                                    a.type_hint.clone().to_str(),
                                    a.name.clone()
                                ));
                                if i != args.clone().len() - 1 {
                                    self.emit(",");
                                }
                                context.add(Var::new(
                                    a.name.clone(),
                                    0,
                                    a.type_hint.clone(),
                                    false,
                                    a.is_ref,
                                    None,
                                    None,
                                    m.clone().unwrap().span,
                                ));
                            }
                            self.emit(");");
                            let mut f = Function::new(
                                fname.clone(),
                                context,
                                ret_type.clone(),
                                returns,
                                body.clone().node,
                            );
                            f.args = args;
                            self.register_plugin(Type::Custom(name.clone()), f);
                        }
                    }
                    for meth in meths.clone() {
                        if let Spanned {
                            node:
                                AstNode::FnStmt {
                                    body,
                                    args,
                                    name: fname,
                                    ret_type,
                                    returns,
                                    return_val,
                                    vardaic,
                                    mangled_name,
                                },
                            span,
                        } = meth.clone().unwrap().clone()
                        {
                            let p = AstNode::PluginStatement {
                                name: fname.clone(),
                                ret_val: return_val,
                                ret_type: Box::new(ret_type.clone()),
                                body: body.clone(),
                                targ_type: Type::Custom(name.clone()),
                                args: args.clone(),
                            };

                            self.generate(vec![Spanned { node: p, span }]);
                        }
                    }
                    self.cur_section = save;
                }
                AstNode::GenericBlockStmt {
                    name,
                    fields,
                    meths,
                    generics,
                } => {
                    self.cur_body_type = BodyType::GENERIC;
                    let layout: BlockLayout;
                    let mut b_fields: HashMap<String, FieldLayout> = HashMap::new();
                    let save = self.cur_section.clone();
                    self.cur_section = Section::Header;
                    // self.emit(format!("\njaguar_deftype({});", name.clone()).as_str());
                    self.emit(&format!(
                        "\n\n#define GENERIC_BLOCK_{}(",
                        name.to_uppercase()
                    ));
                    let mut gname = name.clone();
                    for (i, generic) in generics.clone().iter().enumerate() {
                        self.emit(&format!("{}", generic));
                        gname += &format!("_##{generic}");
                        if i != generics.len() - 1 {
                            self.emit(",");
                        }
                    }
                    self.emit(") ");
                    self.emit(format!("typedef struct {gname} {{\\").as_str());

                    for (_i, field) in fields.clone().iter().enumerate() {
                        if let AstNode::Feilds {
                            name: fname,
                            type_hint,
                        } = field.node.clone()
                        {
                            self.emit(format!("\n\t{} {fname}; \\", type_hint.to_str()).as_str());
                            b_fields.insert(fname.clone(), FieldLayout { ty: type_hint });
                        }
                    }
                    layout = BlockLayout {
                        name: Type::Custom(name.clone()),
                        feilds: b_fields.clone(),
                        methods: Vec::new(),
                        file: self.current_file.clone(),
                    };
                    self.types.add_type(Type::Custom(name.clone()), layout);
                    self.emit(format!("\n}} {gname};").as_str());
                    for m in meths.clone() {
                        if let Spanned {
                            node:
                                AstNode::FnStmt {
                                    body,
                                    args,
                                    name: fname,
                                    ret_type,
                                    returns,
                                    return_val,
                                    vardaic,
                                    mangled_name,
                                },
                            span,
                        } = m.clone().unwrap()
                        {
                            let targ_type = Type::Custom(name.clone());
                            let layout = self.get_layout(targ_type.clone());
                            if matches!(layout, None) {
                                println!(
                                    "ToDo Err system: Not a type {}",
                                    targ_type.debug().clone()
                                );
                                exit(1);
                            }
                            match layout
                                .as_ref()
                                .unwrap()
                                .clone()
                                .methods
                                .clone()
                                .iter()
                                .find(|m| m.get_name() == fname.clone())
                            {
                                Some(plug) => {
                                    println!(
                                        "ToDo Err system: Plugin {} already exsist for type {}",
                                        fname.clone(),
                                        targ_type.debug().clone()
                                    );
                                    exit(1);
                                }
                                None => (),
                            }
                            let mut context = Context::new(
                                name.clone(),
                                Some(Box::new(self.current_context.clone())),
                            );
                            self.emit(&format!(
                                "\nextern inline {} {}_{}(",
                                ret_type.clone().to_str(),
                                targ_type.to_str(),
                                fname.clone()
                            ));
                            for (i, a) in args.clone().iter_mut().enumerate() {
                                let mut modif = "";
                                if a.name == "self" {
                                    modif = "*";
                                    a.type_hint = targ_type.clone();
                                    self.emit(&format!("{gname}{modif} {}", a.name.clone()));
                                } else {
                                    self.emit(&format!(
                                        "{}{modif} {}",
                                        a.type_hint.clone().to_str(),
                                        a.name.clone()
                                    ));
                                }
                                if i != args.clone().len() - 1 {
                                    self.emit(",");
                                }
                                context.add(Var::new(
                                    a.name.clone(),
                                    0,
                                    a.type_hint.clone(),
                                    false,
                                    a.is_ref,
                                    None,
                                    None,
                                    m.clone().unwrap().span,
                                ));
                            }
                            self.emit("); \\");
                            let mut f = Function::new(
                                fname.clone(),
                                context,
                                ret_type.clone(),
                                returns,
                                body.clone().node,
                            );
                            f.args = args;
                            self.register_plugin(Type::Custom(name.clone()), f);
                        }
                    }
                    for meth in meths.clone() {
                        if let Spanned {
                            node:
                                AstNode::FnStmt {
                                    body,
                                    args,
                                    name: fname,
                                    ret_type,
                                    returns,
                                    return_val,
                                    vardaic,
                                    mangled_name,
                                },
                            span,
                        } = meth.clone().unwrap().clone()
                        {
                            let p = AstNode::PluginStatement {
                                name: fname.clone(),
                                ret_val: return_val,
                                ret_type: Box::new(ret_type.clone()),
                                body: body.clone(),
                                targ_type: Type::Custom(name.clone()),
                                args: args.clone(),
                            };

                            self.generate(vec![Spanned { node: p, span }]);
                        }
                    }
                    self.cur_section = save;
                    let mut g = vec![];
                    for s in generics {
                        g.push(Type::Custom(s));
                    }
                    self.generics.push(Generic {
                        name: Type::Custom(name),
                        generics: g,
                    });
                    self.cur_body_type = BodyType::NORMAL;
                }
                AstNode::ReVal { name, value } => {
                    let s = self.gen_expr(Box::new(node), Type::Any, RefStyle::COPY);
                    self.emit(&format!("\n\t{};", s.stream));
                }
                AstNode::IfStmt {
                    cond,
                    body,
                    elseifs,
                    elsestmt,
                } => {
                    self.emit("\nif (");
                    let cout = self.gen_expr(cond, Type::Any, RefStyle::COPY);
                    self.emit(&cout.stream);
                    self.emit("){\n");
                    self.generate(match body.node {
                        AstNode::Program(k) => k,
                        _ => vec![],
                    });
                    self.emit("\n}");
                }
                AstNode::ForStmt {
                    init,
                    cond,
                    inc,
                    body,
                } => {
                    self.emit("\nfor (");
                    if let AstNode::ReVal { name, value } = init.clone().node {
                        if let AstNode::Token(v, _) = name.node.clone() {
                            self.current_context.add(Var::new(
                                v,
                                0,
                                Type::INT,
                                false,
                                false,
                                None,
                                None,
                                name.clone().span,
                            ));
                        }
                    }
                    let iniout = self.gen_expr(init, Type::Any, RefStyle::COPY);
                    self.emit("jaguar_int ");
                    self.emit(&iniout.stream);
                    self.emit(";");
                    let condout = self.gen_expr(cond, Type::Any, RefStyle::COPY);
                    self.emit(&condout.stream);
                    self.emit(";");
                    self.emit("(");
                    let incout = self.gen_expr(inc, Type::Any, RefStyle::COPY);
                    self.emit(&incout.stream);
                    self.emit(")");
                    self.emit(") {");
                    self.generate(match body.node {
                        AstNode::Program(k) => k,
                        _ => vec![],
                    });
                    self.emit("}\n");
                }
                AstNode::BREAK => {
                    self.emit(&format!("break;"));
                }
                AstNode::CONTINUE => {
                    self.emit("\ncontinue;");
                }
                AstNode::FnStmt {
                    body,
                    name,
                    ret_type,
                    returns,
                    return_val,
                    args,
                    vardaic,
                    mangled_name,
                } => {
                    let mut fn_ret = ret_type.clone();
                    let mut fmangled_name = name.clone();
                    if name == "main".to_string() {
                        fmangled_name = name.clone();
                        fn_ret = Type::INT;
                    }
                    self.emit("\n");
                    self.change_scope(name.as_str());
                    self.cur_section = Section::FUNC;
                    let saved_offset: u16 = self.cur_offset;
                    self.cur_offset = 1;
                    self.emit("\n");
                    if self.is_included {
                        self.emit("extern inline ");
                    }
                    if !returns.clone() && name != "main" {
                        self.emit(format!("void {name}(").as_str());
                    } else {
                        self.emit(format!("{} {name} (", fn_ret.to_str()).as_str());
                    }
                    let mut index: u16 = 0;
                    for arg in args.clone() {
                        self.emit(format!("{} {}", arg.type_hint.to_str(), arg.name).as_str());
                        if index != (args.len() - 1 as usize) as u16 {
                            self.emit(",");
                        }
                        let v = Var::new(
                            arg.name,
                            self.cur_offset - 1,
                            arg.type_hint,
                            false,
                            false,
                            None,
                            None,
                            node.clone().span,
                        );
                        self.var_table.add(v.clone());
                        self.current_context.add(v);
                        index += 1;
                    }
                    self.emit(") {");
                    self.track_rsp = true;
                    self.generate(match body.node.clone() {
                        AstNode::Program(k) => k.clone(),
                        _ => Vec::new(),
                    });
                    if returns {
                        if ret_type == Type::NoType {
                            self.consume(CompileError::new(
                                format!(
                                "Cannot pass return value to function '{}' that returns nothing",
                                name
                            ),
                                Some("Remove the return statement".into()),
                                return_val.clone().unwrap().span,
                                ErrLevel::WARNING,
                            ));
                        }
                        let out = self.gen_expr(
                            Box::new(return_val.clone().unwrap()),
                            ret_type.clone(),
                            RefStyle::COPY,
                        );
                        if !self.type_match(ret_type.clone(), *out.type_hint.clone()) {
                            self.consume(CompileError::new(
                                format!(
                                    "returning {} when {} was expected",
                                    out.clone().type_hint.debug(),
                                    ret_type.clone().debug(),
                                ),
                                None,
                                return_val.clone().unwrap().span,
                                ErrLevel::ERROR,
                            ));
                        }
                        self.emit(format!("\n\treturn {};", out.stream.clone()).as_str());
                        self.track_rsp = false;
                        self.rsp_alloc = 0;
                    } else {
                        if ret_type != Type::NoType {
                            self.consume(CompileError::new(
                                format!(
                                    "Function '{}' expected to return {:?} but returned nothing",
                                    name, ret_type
                                ),
                                None,
                                node.span,
                                ErrLevel::WARNING,
                            ));
                        }
                        self.track_rsp = false;
                        self.rsp_alloc = 0;
                    }
                    if name == "main" && fn_ret == Type::INT {
                        self.emit("\n\treturn 0;");
                    }
                    self.emit("\n}\n");
                    let mut func = Function::new(
                        name,
                        self.current_context.clone(),
                        fn_ret.clone(),
                        returns,
                        body.node,
                    );
                    func.args = args.clone();
                    self.func_table.push(func);
                    self.exit_scope();
                    self.cur_offset = saved_offset;
                    self.cur_section = Section::TEXT;
                    continue;
                }
                AstNode::GenericFnCall {
                    callee,
                    generics,
                    args,
                } => {
                    println!("Calling {callee:?} with {generics:?}generics");
                    let t = self.gen_expr(Box::new(node), Type::Any, RefStyle::COPY);
                    self.emit(&format!("{};", t.stream));
                }
                AstNode::GenericFnStmt {
                    generics,
                    body,
                    args,
                    name,
                    ret_type,
                    returns,
                    return_val,
                    vardaic,
                    mangled_name,
                } => {
                    self.cur_section = Section::FUNC;
                    let mut stream = String::new();
                    let instantiator_name = format!("GENERIC_FN_{name}");
                    self.emit(&format!("\n\n#define {instantiator_name}("));
                    for (i, g) in generics.clone().iter().enumerate() {
                        self.emit(&format!("{g}"));
                        if i != generics.len() - 1 {
                            self.emit(",");
                        }
                    }
                    self.emit(") ");
                    let mut fn_ret = ret_type.clone();
                    let mut fmangled_name = name.clone();
                    if name == "main".to_string() {
                        fmangled_name = name.clone();
                        fn_ret = Type::INT;
                    }
                    self.change_scope(name.as_str());
                    self.cur_section = Section::FUNC;
                    let saved_offset: u16 = self.cur_offset;
                    self.cur_offset = 1;
                    if self.is_included {
                        self.emit(&format!("extern inline "));
                    }
                    if !returns.clone() && name != "main" {
                        self.emit(&format!("void {name}("));
                    } else {
                        self.emit(&format!("{} {name} (", fn_ret.genimpl()));
                    }
                    let mut index: u16 = 0;
                    for arg in args.clone() {
                        self.emit(&format!("{} {}", arg.type_hint.to_str(), arg.name));
                        if index != (args.len() - 1 as usize) as u16 {
                            self.emit(&format!(","));
                        }
                        let v = Var::new(
                            arg.name,
                            self.cur_offset - 1,
                            arg.type_hint,
                            false,
                            false,
                            None,
                            None,
                            node.clone().span,
                        );
                        self.var_table.add(v.clone());
                        self.current_context.add(v);
                        index += 1;
                    }
                    self.emit(&format!(") {{"));
                    self.track_rsp = true;
                    self.generate(match body.node.clone() {
                        AstNode::Program(k) => k.clone(),
                        _ => Vec::new(),
                    });
                    if returns {
                        if ret_type == Type::NoType {
                            self.consume(CompileError::new(
                                format!(
                                "Cannot pass return value to function '{}' that returns nothing",
                                name
                            ),
                                Some("Remove the return statement".into()),
                                return_val.clone().unwrap().span,
                                ErrLevel::WARNING,
                            ));
                        }
                        let out = self.gen_expr(
                            Box::new(return_val.clone().unwrap()),
                            ret_type.clone(),
                            RefStyle::COPY,
                        );
                        if !self.type_match(ret_type.clone(), *out.type_hint.clone()) {
                            self.consume(CompileError::new(
                                format!(
                                    "returning {} when {} was expected",
                                    out.clone().type_hint.debug(),
                                    ret_type.clone().debug(),
                                ),
                                None,
                                return_val.clone().unwrap().span,
                                ErrLevel::ERROR,
                            ));
                        }
                        self.emit(&format!("\\\n\treturn {};\\", out.stream.clone()));
                    } else {
                        if ret_type != Type::NoType {
                            self.consume(CompileError::new(
                                format!(
                                    "Function '{}' expected to return {:?} but returned nothing",
                                    name, ret_type
                                ),
                                None,
                                node.span,
                                ErrLevel::WARNING,
                            ));
                        }
                    }
                    if name == "main" && fn_ret == Type::INT {
                        self.emit(&format!("\\\n\treturn 0;\\"));
                    }
                    self.emit(&format!("\n}}\n"));
                    let mut func = Function::new(
                        name.clone(),
                        self.current_context.clone(),
                        fn_ret.clone(),
                        returns,
                        body.node,
                    );
                    func.args = args.clone();
                    self.gfunc_table.push(func);
                    self.exit_scope();
                    self.cur_offset = saved_offset;
                    self.cur_section = Section::TEXT;
                    let mut g = vec![];
                    for s in generics {
                        g.push(Type::Custom(s));
                    }
                    self.generics.push(Generic {
                        name: Type::Custom(name),
                        generics: g,
                    });
                    continue;
                }
                AstNode::BinaryExpr { lhs, opr, rhs } => {}
                AstNode::ExTernStmt {
                    name,
                    args: params,
                    return_type,
                    vardaic,
                } => {
                    let mut stream = String::new();
                    let mut context = Context::new(name.clone(), None);
                    stream += format!("\nextern {} {name} (", return_type.to_str()).as_str();
                    for (i, arg) in params.clone().iter().enumerate() {
                        let v = Var::new(
                            arg.clone().name,
                            0,
                            arg.type_hint.clone(),
                            false,
                            false,
                            None,
                            None,
                            node.clone().span,
                        );
                        stream +=
                            format!("{} {}", arg.type_hint.clone().to_str(), arg.name.clone())
                                .as_str();
                        context.add(v);
                        if i != (params.clone().len() - 1 as usize) as usize {
                            stream += ",";
                        }
                    }
                    if vardaic {
                        stream += ", ...";
                    }
                    stream += ");";
                    let mut extrnfunc = Function::new(
                        name.clone(),
                        context,
                        return_type,
                        true,
                        AstNode::Program(Vec::new()),
                    );
                    extrnfunc.args = params;
                    extrnfunc.variadic = vardaic;
                    self.func_table.push(extrnfunc);
                    self.cur_section = Section::Header;
                    self.emit(&stream);
                    self.cur_section = Section::TEXT;
                    continue;
                }
                AstNode::FcCall { params, callee } => {
                    self.emit("\n\t");
                    let out = self.gen_func_call(Box::new(node.clone()), Type::Any);
                    self.emit(out.stream.as_str());
                    self.emit(";");
                }
                AstNode::PluginStatement {
                    name,
                    ret_val,
                    ret_type,
                    body,
                    targ_type,
                    args,
                } => {
                    let plugin_name = name.clone();
                    let plugin_type = ret_type.clone();
                    let plugin_val = ret_val.clone();

                    self.change_scope(name.as_str());
                    self.cur_section = Section::FUNC;
                    self.emit(
                        format!(
                            "\n\nextern inline {} {}_{}(",
                            plugin_type.to_str().clone(),
                            targ_type.to_str().clone(),
                            plugin_name.clone()
                        )
                        .as_str(),
                    );
                    for (index, arg) in args.clone().iter_mut().enumerate() {
                        let mut modifier = "";
                        if arg.name.clone() == "self" {
                            modifier = "*";
                            self.current_context.add(Var::new(
                                "self".into(),
                                0,
                                targ_type.clone(),
                                false,
                                true,
                                None,
                                None,
                                node.clone().span,
                            ));
                            arg.type_hint = targ_type.clone();
                        } else {
                            self.current_context.add(Var::new(
                                arg.name.clone(),
                                0,
                                arg.type_hint.clone(),
                                false,
                                arg.is_ref.clone(),
                                None,
                                None,
                                node.clone().span,
                            ));
                        }

                        self.emit(&format!(
                            "{} {}{}",
                            arg.type_hint.to_str(),
                            modifier,
                            arg.name
                        ));
                        if index != args.len() - 1 {
                            self.emit(",");
                        }
                    }
                    self.emit(") {");
                    self.generate(match body.clone().node.clone() {
                        AstNode::Program(k) => k.clone(),
                        _ => Vec::new(),
                    });
                    if ret_val.is_some() {
                        let out = self
                            .gen_expr(
                                Box::new(ret_val.clone().unwrap()),
                                *ret_type.clone(),
                                RefStyle::COPY,
                            )
                            .clone();
                        if !self.type_match(*ret_type.clone(), *out.clone().type_hint) {
                            self.consume(CompileError::new(
                                format!(
                                    "returning {} when {} was expected",
                                    out.clone().type_hint.debug(),
                                    ret_type.clone().debug(),
                                ),
                                None,
                                ret_val.clone().unwrap().span,
                                ErrLevel::ERROR,
                            ));
                        }
                        self.emit(&format!("\n\treturn {};", out.stream.clone()));
                    }
                    self.emit("\n}\n");
                    let mut flayout = self.get_layout(targ_type.clone());
                    let mut plugin = Function::new(
                        plugin_name.clone(),
                        self.current_context.clone(),
                        *ret_type.clone(),
                        true,
                        body.clone().node,
                    );
                    plugin.args = args;
                    // self.register_plugin(targ_type.clone(), plugin);
                    self.cur_section = Section::TEXT;
                    self.exit_scope();
                }
                AstNode::UnpackStmt { alias, symbols } => {
                    /* pull symbols from 'symbols' into the global context */
                    let bndl = self.bundles.iter().find(|b| b.name == alias).cloned();
                    if !bndl.is_some() {
                        self.consume(CompileError::new(
                            format!("No Bundle named {alias}"),
                            None,
                            node.clone().span,
                            ErrLevel::ERROR,
                        ));
                        self.flush();
                    }
                    let mut b = bndl.clone().unwrap();
                    for sym in symbols.clone() {
                        let f = b.functions.iter().find(|f| f.get_name() == sym);
                        let tf = self.func_table.iter().find(|f| f.get_name() == sym);
                        if f.is_some() {
                            if tf.is_some() {
                                self.consume(CompileError::new(
                                    format!("Conflicting symbol {sym}. Function with this name already exists in the scope"), None, node.clone().span, ErrLevel::ERROR
                                ));
                                self.flush();
                            }
                            self.func_table.push(f.unwrap().clone());
                            continue;
                        }
                        let bn = b.bundles.iter().find(|b| b.name == sym);
                        let tbn = self.bundles.iter().find(|b| b.name == sym);
                        if bn.is_some() {
                            if tbn.is_some() {
                                self.consume(CompileError::new(
                                    format!("Conflicting symbol {sym}. Bundle with this alias already exists in the scope"), None, node.clone().span, ErrLevel::ERROR
                                ));
                                self.flush();
                            }
                            self.bundles.push(bn.unwrap().clone());
                            continue;
                        }
                        let v = b.vars.lookup(&sym);
                        let tv = self.var_table.lookup(&sym);
                        if v.is_some() {
                            if tv.is_some() {
                                self.consume(CompileError::new(
                                    format!("Conflicting symbol {sym}. Variable with this name already exists in the scope"), None, node.clone().span, ErrLevel::ERROR
                                ));
                                self.flush();
                            }
                            self.current_context.add(v.unwrap().clone());
                            continue;
                        }
                        let mut t = b.types.getLayout(Type::Custom(sym.clone()));
                        let tt = self.types.getLayout(Type::Custom(sym.clone()));
                        if t.is_some() {
                            if tt.is_some() {
                                self.consume(CompileError::new(
                                    format!("Conflicting symbol {sym}. Type with this name already exists in the scope"), None, node.clone().span, ErrLevel::ERROR
                                ));
                                self.flush();
                            }
                            t.as_mut().unwrap().name = Type::Custom(sym.clone());
                            self.types
                                .add_type(t.clone().unwrap().name, t.clone().unwrap());
                            continue;
                        }
                        self.consume(CompileError::new(
                            format!("Undefined symbol {sym}"),
                            None,
                            node.clone().span,
                            ErrLevel::ERROR,
                        ));
                        self.flush();
                    }
                }
                _ => {
                    let out = self
                        .gen_expr(Box::new(node), Type::Any, RefStyle::COPY)
                        .clone();
                    self.emit(&format!("{};", out.stream));
                    continue;
                }
            }
        }
    }
    pub fn rest(&mut self) {
        self.flush();
        if !self.is_included {
            self.outfilepath = format!("{}.c", self.outfilepath);
        } else {
            self.outfilepath = format!("{}", self.outfilepath);
        }
        let mut outfile = File::create(self.outfilepath.clone()).unwrap();
        outfile.write(self.bss.as_bytes()).unwrap();
        outfile.write(self.data.as_bytes()).unwrap();
        outfile.write(self.header.as_bytes()).unwrap();
        outfile.write(self.text.as_bytes()).unwrap();
        outfile.write(self.func.as_bytes()).unwrap();
    }
    fn name_mangler(&mut self, input: String) -> String {
        let mut new_name: String = String::new();
        let prefix = "_Tixie";
        let path = self.outfilename.clone();
        new_name
    }
    fn gen_expr(
        &mut self,
        expression: Box<Spanned<AstNode>>,
        target_type: Type,
        is_ref: RefStyle,
    ) -> ExprResult {
        let mut stream = String::new();
        let v_is_ref = false;
        let v_is_deref = false;
        let v_is_moved = false;
        let expr = expression.as_ref();
        match expr.node.clone() {
            AstNode::LiteralInt(num) => {
                if (is_int(target_type.clone())) || (target_type == Type::Any) {
                    match is_ref {
                        RefStyle::DEREF => {
                            self.consume(CompileError::new(
                                format!("Cannot De-reference Value of a literal"),
                                Some("Remove the * operator".into()),
                                expr.clone().span,
                                ErrLevel::ERROR,
                            ));
                            self.flush();
                        }
                        RefStyle::MOVE => {
                            self.consume(CompileError::new(
                                format!("Cannot move a literal"),
                                Some("Remove the % operator".into()),
                                expr.clone().span,
                                ErrLevel::ERROR,
                            ));
                            self.flush();
                        }
                        RefStyle::REF => {
                            self.consume(CompileError::new(
                                format!("Cannot reference a literal"),
                                Some("Remove the & operator".into()),
                                expr.clone().span,
                                ErrLevel::ERROR,
                            ));
                            self.flush();
                        }
                        _ => {}
                    }
                }
                self.check_overflow(num.parse::<i128>().unwrap(), target_type, expr.clone().span);
                stream.push_str(format!("{}", num).as_str());
                return ExprResult {
                    stream,
                    is_ref: false,
                    is_moved: false,
                    is_deref: false,
                    refed_var: None,
                    moved_from: None,
                    type_hint: Box::new(Type::INT),
                    var: None,
                };
            }
            AstNode::LiteralStr(value) => {
                if matches!(is_ref, RefStyle::REF) {
                    self.consume(CompileError::new(
                        format!("Cannot reference an immediate value"),
                        Some("Consider Removing the & operator".to_owned()),
                        expr.clone().span,
                        ErrLevel::ERROR,
                    ));
                } else if matches!(is_ref, RefStyle::DEREF) {
                    self.consume(CompileError::new(
                        format!("Cannot dereference an immediate value"),
                        Some("Consider Removing the * operator".to_owned()),
                        expr.clone().span,
                        ErrLevel::ERROR,
                    ));
                }
                let save = self.cur_section.clone();
                self.cur_section = save;
                self.immediate_counter += 1;
                return ExprResult {
                    stream: format!("\"{value}\""),
                    is_ref: false,
                    is_moved: false,
                    is_deref: false,
                    refed_var: None,
                    moved_from: None,
                    type_hint: Box::new(Type::STR),
                    var: Some(format!("(const char*)\"{value}\"")),
                };
            }
            AstNode::LiteralCh(value) => {
                if matches!(is_ref, RefStyle::REF) {
                    self.consume(CompileError::new(
                        format!("Cannot reference an immediate value"),
                        Some("Consider Removing the & operator".to_owned()),
                        expr.clone().span,
                        ErrLevel::ERROR,
                    ));
                } else if matches!(is_ref, RefStyle::DEREF) {
                    self.consume(CompileError::new(
                        format!("Cannot dereference an immediate value"),
                        Some("Consider Removing the * operator".to_owned()),
                        expr.clone().span,
                        ErrLevel::ERROR,
                    ));
                }
                let save = self.cur_section.clone();
                self.cur_section = save;
                self.immediate_counter += 1;
                return ExprResult {
                    stream: format!("\'{value}\'"),
                    is_ref: false,
                    is_moved: false,
                    is_deref: false,
                    refed_var: None,
                    moved_from: None,
                    type_hint: Box::new(Type::CHAR),
                    var: Some(format!("(const char*)\"{value}\"")),
                };
            }
            AstNode::GenericFnCall {
                callee,
                generics,
                args,
            } => match callee.clone().node {
                AstNode::Token(v, d) => {
                    let fnc = self.gfunc_table.iter().find(|p| p.get_name() == v).cloned();
                    if fnc.is_none() {
                        self.consume(CompileError::new(
                            format!("Use of undeclared symbol '{v}'"),
                            None,
                            callee.clone().span,
                            ErrLevel::ERROR,
                        ));
                        self.flush();
                        exit(1);
                    }
                    let fnm = fnc.unwrap().clone();
                    let mut new_func = fnm.clone();
                    match fnm.ty.clone() {
                        Type::Generic {
                            base,
                            generics: grcs,
                        } => {
                            // println!("Given generics: {generics:?}\nrequired generics {grcs:?}");
                            new_func.ty = Type::Generic {
                                base: base.clone(),
                                generics: generics.clone(),
                            };
                            if self
                                .generics
                                .iter()
                                .find(|p| p.name == fnm.ty.clone())
                                .is_none()
                            {
                                let mut l = self.get_layout(fnm.ty);
                                let mut nl = l.clone().unwrap();
                                for f in l.unwrap().feilds.iter().enumerate() {
                                    if grcs.iter().find(|p| **p == f.1.1.ty).is_some() {
                                        nl.feilds.get_mut(f.1.0).unwrap().ty =
                                            generics.get(f.0).unwrap().clone()
                                    }
                                }
                                nl.name = new_func.ty.clone();
                                println!("{nl:?}");
                                self.types.add_type(nl.name.clone(), nl);
                            }
                            for (i, arg) in new_func.clone().args.iter().enumerate() {
                                if grcs.iter().find(|p| **p == arg.type_hint).is_some() {
                                    new_func.args.get_mut(i).unwrap().type_hint =
                                        generics.get(i).unwrap().clone();
                                }
                            }
                            self.func_table.push(new_func);
                            stream += &format!("\n\nGENERIC_FN_{v}(");
                            for t in generics.iter().enumerate() {
                                stream += &format!("{}", t.1.to_str());
                                if t.0 != generics.len() - 1 {
                                    stream += &format!(",");
                                }
                            }
                            stream += &format!(")\n\n");
                            let n = Spanned {
                                node: AstNode::FcCall {
                                    params: args,
                                    callee: callee.clone(),
                                },
                                span: expr.span.clone(),
                            };
                            let f = self.gen_func_call(Box::new(n), target_type);
                            return ExprResult {
                                stream,
                                is_ref: false,
                                is_moved: false,
                                is_deref: false,
                                refed_var: None,
                                moved_from: None,
                                type_hint: Box::new(f.type_hint),
                                var: None,
                            };
                        }
                        _ => {}
                    }
                }
                _ => {}
            },
            AstNode::ListInit { content } => {
                let save = self.cur_section.clone();
                self.cur_section = Section::Header;
                let mut list_type = Box::new(Type::NoType);
                let mut list_size = String::new();
                if let Type::list(t, n) = target_type.clone() {
                    list_type = t.clone();
                    list_size = n.clone();
                    self.emit(format!("\njaguar_list({}, {});\n", t.to_str(), n).as_str());
                    self.cur_section = save;
                }
                stream += "{.data = {";
                for (i, expr) in content.iter().enumerate() {
                    let out = self.gen_expr(expr.clone(), Type::Any, is_ref.clone());
                    list_type = out.type_hint.clone();
                    stream += out.stream.clone().as_str();
                    if i != content.len() - 1 {
                        stream += ",";
                    }
                    if i >= (list_size.parse::<u32>().unwrap()) as usize {
                        self.consume(CompileError::new(format!("Excess elements passed to array initializer. expected only {} but got {}+", list_size.clone(), i), None,expr.clone().span , ErrLevel::ERROR));
                        self.flush();
                    }
                }
                stream += format!("}}, .len = {list_size}}}").as_str();

                return ExprResult {
                    stream: stream.clone(),
                    is_ref: false,
                    is_moved: false,
                    is_deref: false,
                    refed_var: None,
                    moved_from: None,
                    type_hint: Box::new(Type::list(list_type, list_size)),
                    var: Some(stream),
                };
            }
            AstNode::ListAccess { name, index } => {
                match name.node.clone() {
                    AstNode::MemberAccess { base, field } => {
                        let b = self.gen_expr(name.clone(), target_type, RefStyle::COPY);
                        let v = self
                            .lookup_variable(&b.var.clone().unwrap())
                            .unwrap()
                            .clone();
                        let layout = self.get_layout(v.clone().type_hint).clone();
                        if matches!(layout, None) {
                            self.consume(CompileError::new(
                                format!("Not a type, '{}'", b.clone().type_hint.debug()),
                                None,
                                base.span,
                                ErrLevel::ERROR,
                            ));
                            self.flush();
                        }
                        let mut l = layout.clone().unwrap();
                        let f = l.feilds.iter_mut().find(|p| p.0.to_string() == field);
                        if matches!(f, None) {
                            self.consume(CompileError::new(
                                format!(
                                    "Type '{}' has no field {field}",
                                    v.clone().type_hint.debug()
                                ),
                                None,
                                expr.clone().span,
                                ErrLevel::ERROR,
                            ));
                            self.flush();
                        }
                        let fl = f.unwrap().1.ty.clone();
                        let mut ty = Type::NoType;
                        if !self.is_iterable(fl.clone()) {}
                        let i = self.gen_expr(index, Type::Any, RefStyle::COPY);
                        if let Type::list(v, c) = fl.clone() {
                            stream += &format!("jaguar_list_at({}, {})", b.stream, i.stream);
                            ty = *v.clone();
                        } else if let Type::PTR(v) = fl.clone() {
                            stream += &format!("{}[{}]", b.stream, i.stream);
                            ty = *v.clone();
                        } else if let Type::STR = fl.clone() {
                            stream += &format!("{}[{}]", b.stream, i.stream);
                            ty = Type::CHAR;
                        }
                        return ExprResult {
                            stream: stream.clone(),
                            is_ref: false,
                            is_moved: false,
                            is_deref: false,
                            refed_var: None,
                            moved_from: None,
                            type_hint: Box::new(ty),
                            var: Some("foo".to_owned()),
                        };
                    }
                    AstNode::Token(v, t) => {
                        let t = self.gen_expr(name.clone(), target_type, RefStyle::COPY);
                        let fl = *t.type_hint.clone();
                        let mut ty = Type::NoType;
                        if !self.is_iterable(fl.clone()) {}
                        let i = self.gen_expr(index, Type::Any, RefStyle::COPY);
                        if let Type::list(v, c) = fl.clone() {
                            stream += &format!("jaguar_list_at({}, {})", t.stream, i.stream);
                            ty = *v.clone();
                        } else if let Type::PTR(v) = fl.clone() {
                            stream += &format!("{}[{}]", t.stream, i.stream);
                            ty = *v.clone();
                        } else if let Type::STR = fl.clone() {
                            stream += &format!("{}[{}]", t.stream, i.stream);
                            ty = Type::CHAR;
                        }
                        return ExprResult {
                            stream: stream.clone(),
                            is_ref: false,
                            is_moved: false,
                            is_deref: false,
                            refed_var: None,
                            moved_from: None,
                            type_hint: Box::new(ty),
                            var: Some("foo".to_owned()),
                        };
                    }

                    _ => {}
                }
                return ExprResult {
                    stream: stream.clone(),
                    is_ref: false,
                    is_moved: false,
                    is_deref: false,
                    refed_var: None,
                    moved_from: None,
                    type_hint: Box::new(Type::NoType),
                    var: Some("foo".to_owned()),
                };
            }
            AstNode::BlockInit { fields } => {
                let block_name = target_type.clone();
                let block_fields = fields.clone();
                if let Type::Generic { base, generics } = target_type.clone() {
                    let l = self.get_layout(*base.clone());
                    if !l.is_some() {
                        self.consume(CompileError::new(
                            format!("Not a type, {}", block_name.debug()),
                            None,
                            expr.clone().span,
                            ErrLevel::ERROR,
                        ));
                        self.flush();
                    }
                    let v_fields = l.clone().unwrap().feilds;
                    stream += "{";
                    for (i, b) in block_fields.clone().iter().enumerate() {
                        if let AstNode::Pair { field, value } = b.clone().node {
                            if v_fields.contains_key(&field) {
                                let f = v_fields.get(&field).unwrap();
                                let o = self.gen_expr(value, Type::Any, RefStyle::COPY);
                                stream += &format!(".{field} = {}", o.stream);
                                if i != block_fields.len() - 1 {
                                    stream += ","
                                }
                            }
                        }
                    }
                    stream += "}";
                    // Swapping all generic types in old layout and creating a new layout
                    let mut new_layout = l.clone().unwrap();
                    let g = self.generics.iter().find(|p| p.name == *base);
                    for (i, field) in &mut new_layout.feilds.iter_mut().enumerate() {
                        if g.unwrap().generics.contains(&field.1.ty) {
                            field.1.ty = generics.get(i).unwrap().clone();
                        }
                    }
                    self.types.add_type(target_type.clone(), new_layout); // adding new layout to type registary
                    return ExprResult {
                        stream: stream.clone(),
                        is_ref: false,
                        is_moved: false,
                        is_deref: false,
                        refed_var: None,
                        moved_from: None,
                        type_hint: Box::new(target_type),
                        var: Some(stream),
                    };
                }
                if self.verifyType(block_name.clone()) == None {
                    self.consume(CompileError::new(
                        format!("Not a type, {}", block_name.debug()),
                        None,
                        expr.clone().span,
                        ErrLevel::ERROR,
                    ));
                    self.flush();
                }
                let _block_size = self.verifyType(block_name.clone());
                let mut t = self.resolve_type(block_name.clone());
                if let Type::PTR(v) = t {
                    t = *v;
                }
                let layout = self.get_layout(t);
                if matches!(layout, None) {
                    // self.error(format!("Not a type {}", block_name.to_str()), expr);
                    self.consume(CompileError::new(
                        format!("Not a type, {}", block_name.debug()),
                        None,
                        expr.clone().span,
                        ErrLevel::ERROR,
                    ));
                    self.flush();
                }
                stream += "{";
                for (_i, b_field) in block_fields.clone().iter().enumerate() {
                    if let AstNode::Pair { field, value } = b_field.node.clone() {
                        if layout
                            .clone()
                            .unwrap()
                            .clone()
                            .feilds
                            .contains_key(field.clone().as_str())
                        {
                            let v_field =
                                layout.clone().unwrap().feilds.get(&field).unwrap().clone();
                            let out = self
                                .gen_expr(value.clone(), v_field.ty.clone(), RefStyle::COPY)
                                .clone();
                            if !self.type_match(*out.clone().type_hint, v_field.ty.clone()) {
                                self.consume(CompileError::new(
                                    format!(
                                        "Type Mismatch. Expected '{}' but got '{}' instead",
                                        v_field.ty.clone().debug(),
                                        out.type_hint.clone().debug()
                                    ),
                                    None,
                                    value.clone().span,
                                    ErrLevel::ERROR,
                                ));
                                self.flush();
                                exit(100);
                            }
                            stream += &format!(".{} = ", field);
                            stream += out.stream.as_str();
                            if _i != block_fields.len() - 1 {
                                stream += ",";
                            }
                        } else {
                            // self.error(
                            //     format!("Type {} has no field {field}", block_name.debug()),
                            //     &b_field,
                            // );
                            self.consume(CompileError::new(
                                format!("Type {} has no field {field}", block_name.debug()),
                                None,
                                b_field.clone().span,
                                ErrLevel::ERROR,
                            ));
                            self.flush();
                            exit(100);
                        }
                    }
                }
                stream += "}";
                return ExprResult {
                    stream: stream.clone(),
                    is_ref: false,
                    is_moved: false,
                    is_deref: false,
                    refed_var: None,
                    moved_from: None,
                    type_hint: Box::new(block_name.clone()),
                    var: Some(stream),
                };
            }
            AstNode::RefExpr { expr } => {
                let out = self.gen_expr(expr.clone(), target_type, RefStyle::REF);
                if let AstNode::Token(name, is_deref) = &expr.node.clone() {
                    if let Some(var) = self.lookup_variable(name).cloned() {
                        self.set_ref(var);
                    }
                }
                stream += &format!("&{}", out.stream);
                return ExprResult {
                    stream,
                    is_ref: true,
                    is_moved: false,
                    is_deref: false,
                    refed_var: out.refed_var.clone(),
                    moved_from: None,
                    type_hint: Box::new(Type::PTR(out.type_hint)),
                    var: out.var,
                };
            }
            AstNode::DeRefExpr { expr } => {
                let out = self.gen_expr(expr.clone(), target_type, RefStyle::DEREF);
                let mut type_hint = Type::NoType;
                stream += &format!("*{}", out.stream);
                let mut v_var = None;
                if let AstNode::Token(name, is_deref) = &expr.node {
                    v_var = Some(name.clone());

                    if let Some(var) = self.lookup_variable(name).cloned() {
                        // var.is_ref = true;
                        type_hint = var.type_hint.clone();
                    }
                }
                if let Type::PTR(v) = *out.clone().type_hint {
                    type_hint = *v;
                }
                return ExprResult {
                    stream,
                    is_ref: false,
                    is_moved: false,
                    is_deref: true,
                    refed_var: out.refed_var.clone(),
                    moved_from: None,
                    type_hint: Box::new(type_hint),
                    var: v_var,
                };
            }
            AstNode::Token(var, is_deref) => {
                if let Some(val) = self.lookup_variable(var.as_str()).cloned() {
                    match is_ref {
                        RefStyle::DEREF => {
                            stream += format!("{}", val.name).as_str();
                            if !val.is_ref {
                                // self.error(
                                //     format!("Cannot dereference {}; not a reference", var),
                                //     expr,
                                // );

                                self.consume(CompileError::new(
                                    format!("Cannot dereference value at '{var}'. Not a reference"),
                                    None,
                                    expr.clone().span,
                                    ErrLevel::ERROR,
                                ));
                                self.flush();
                            }
                            let mut type_hint = val.type_hint.clone();

                            if let Type::PTR(ty) = val.type_hint.clone() {
                                type_hint = *ty.clone();
                            }
                            return ExprResult {
                                stream,
                                is_ref: false,
                                is_moved: false,
                                is_deref: true,
                                refed_var: Some(var.clone()),
                                moved_from: None,
                                type_hint: Box::new(val.type_hint),
                                var: Some(var),
                            };
                        }
                        RefStyle::MOVE => {
                            stream += format!("{}", val.name).as_str();
                            return ExprResult {
                                stream,
                                is_ref: false,
                                is_moved: true,
                                is_deref: false,
                                refed_var: None,
                                moved_from: Some(var.clone()),
                                type_hint: Box::new(val.type_hint),
                                var: Some(var),
                            };
                        }
                        RefStyle::COPY => {
                            stream += format!("{}", val.name).as_str();
                            return ExprResult {
                                stream,
                                is_ref: val.is_ref,
                                is_moved: false,
                                is_deref: false,
                                refed_var: Some(var.clone()),
                                moved_from: None,
                                type_hint: Box::new(val.type_hint.clone()),
                                var: Some(var),
                            };
                        }
                        RefStyle::REF => {
                            stream += format!("{}", val.name).as_str();
                            self.set_ref(val.clone());
                            return ExprResult {
                                stream,
                                is_ref: true,
                                is_moved: false,
                                is_deref: false,
                                refed_var: Some(var.clone()),
                                moved_from: None,
                                type_hint: Box::new(val.clone().type_hint),
                                var: Some(var),
                            };
                        }
                        _ => (),
                    }
                } else {
                    // self.error(format!("Use of Undeclared Variable '{}'", var), expr);
                    self.consume(CompileError::new(
                        format!("Use of Undeclared Symbol '{var}'"),
                        None,
                        expr.clone().span,
                        ErrLevel::ERROR,
                    ));
                    self.flush();
                }
                return ExprResult {
                    stream,
                    is_ref: false,
                    is_moved: false,
                    is_deref: false,
                    refed_var: None,
                    moved_from: None,
                    type_hint: Box::new(Type::NoType),
                    var: None,
                };
            }
            AstNode::Cast { expr: ex, ty } => {
                let out = self.gen_expr(ex.clone(), target_type, RefStyle::COPY);
                if self.is_castable(*out.type_hint.clone(), ty.clone()) {
                    stream += &format!("({})({})", ty.to_str(), out.stream);
                } else {
                    self.consume(CompileError::new(
                        format!(
                            "Casting from '{}' to '{}' is invalid",
                            out.type_hint.debug(),
                            ty.debug()
                        ),
                        None,
                        expression.span,
                        ErrLevel::ERROR,
                    ));
                    self.flush();
                }
                return ExprResult {
                    stream,
                    is_ref: v_is_ref,
                    is_moved: v_is_moved,
                    is_deref: v_is_deref,
                    refed_var: None,
                    moved_from: None,
                    type_hint: Box::new(ty),
                    var: None,
                };
            }
            AstNode::Ret(v) => {
                let out = self.gen_expr(v, Type::Any, RefStyle::COPY);
                stream += &format!("return {};", out.stream);
                return ExprResult {
                    stream,
                    is_ref: false,
                    is_moved: false,
                    is_deref: false,
                    refed_var: None,
                    moved_from: None,
                    type_hint: Box::new(Type::NoType),
                    var: None,
                };
            }
            AstNode::BREAK => {
                stream += &format!("break;");
                return ExprResult {
                    stream,
                    is_ref: false,
                    is_moved: false,
                    is_deref: false,
                    refed_var: None,
                    moved_from: None,
                    type_hint: Box::new(Type::NoType),
                    var: None,
                };
            }
            AstNode::BinaryExpr { lhs, opr, rhs } => {
                let mut out = self.gen_expr(lhs.clone(), target_type.clone(), RefStyle::COPY);
                if !is_int(*out.type_hint.clone())
                    && opr.clone() != TokenType::Operator("==".to_owned())
                {
                    // self.error(
                    //     format!("Cannot perform arithmethic on type {:?}", out.type_hint),
                    //     &*lhs,
                    // );
                    self.consume(CompileError::new(
                        format!(
                            "Type {} does not support binary arithmetic'",
                            out.type_hint.debug()
                        ),
                        None,
                        lhs.clone().span,
                        ErrLevel::ERROR,
                    ));
                    self.flush();
                }
                stream += format!("( {}", out.stream.clone()).as_str();
                out = self.gen_expr(rhs.clone(), target_type.clone(), RefStyle::COPY);
                if !is_int(*out.type_hint.clone())
                    && opr.clone() != TokenType::Operator("==".to_owned())
                {
                    // self.error(
                    //     format!("Cannot perform arithmethic on type {:?}", out.type_hint),
                    //     &*rhs,
                    // );
                    self.consume(CompileError::new(
                        format!(
                            "Type {} does not support binary arithmetic'",
                            out.type_hint.debug()
                        ),
                        None,
                        rhs.clone().span,
                        ErrLevel::ERROR,
                    ));
                    self.flush();
                }
                match opr {
                    crate::lexer::TokenType::Operator(val) if val == "+".to_owned() => {
                        stream += "+";
                    }
                    crate::lexer::TokenType::Operator(val) if val == "-".to_owned() => {
                        // stream += "\n\tpush rax";
                        stream += "-";
                        // stream += "\n\tpop rbx";
                    }
                    crate::lexer::TokenType::Operator(val) if val == "*".to_owned() => {
                        stream += "*";
                    }
                    crate::lexer::TokenType::Operator(val) if val == "/".to_owned() => {
                        stream += "/";
                    }
                    crate::lexer::TokenType::Operator(val) => {
                        stream += &val;
                    }
                    _ => {
                        // self.error(format!("Not an Operator {:?}", opr), &*expr);
                        self.consume(CompileError::new(
                            format!("Not an Operator {:#?}", opr),
                            None,
                            expr.clone().span,
                            ErrLevel::ERROR,
                        ));
                        self.flush();
                        exit(1)
                    }
                }
                stream += format!(" {})", out.stream.clone()).as_str();
                return ExprResult {
                    stream: stream.clone(),
                    is_ref: false,
                    is_moved: false,
                    is_deref: false,
                    refed_var: None,
                    moved_from: None,
                    type_hint: Box::new(Type::INT),
                    var: Some(stream),
                };
            }
            AstNode::BundleAccess { base, field } => {
                if let AstNode::Token(var, _) = base.node.clone() {
                    let bndl = self.bundles.iter().find(|b| b.name == var);
                    if matches!(bndl, None) {
                        // self.error(format!("Could not resolve {var}"), &base);
                        self.consume(CompileError::new(
                            format!("Could not resolve {var}"),
                            None,
                            base.clone().span,
                            ErrLevel::ERROR,
                        ));
                        self.flush();
                        exit(100);
                    }
                    if let AstNode::FcCall { params, callee } = field.node.clone() {
                        // let res =
                        //     self.gen_bndl_func(callee, params, bndl.unwrap().clone().functions);
                        let save = self.func_table.clone();
                        self.func_table = bndl.unwrap().functions.clone();
                        let res = self.gen_func_call(field, target_type);
                        self.func_table = save;
                        stream += format!("\n\t{}", res.stream).as_str();
                        return ExprResult {
                            stream,
                            is_ref: false,
                            is_moved: false,
                            is_deref: false,
                            refed_var: None,
                            moved_from: None,
                            type_hint: Box::new(res.type_hint.clone()),
                            var: None,
                        };
                    } else if let AstNode::BundleAccess {
                        base: b2,
                        field: f2,
                    } = field.clone().node
                    {
                        let sb = self.bundles.clone();
                        self.bundles = bndl.clone().unwrap().bundles.clone();
                        let out2 = self.gen_expr(field, target_type, is_ref);
                        stream += &out2.stream;
                        self.bundles = sb.clone();
                        return ExprResult {
                            stream,
                            is_ref: false,
                            is_moved: false,
                            is_deref: false,
                            refed_var: None,
                            moved_from: None,
                            type_hint: Box::new(*out2.type_hint.clone()),
                            var: None,
                        };
                    } else {
                        let out = self.gen_expr(field, target_type, RefStyle::COPY);
                        stream += &out.stream;
                        return ExprResult {
                            stream,
                            is_ref: false,
                            is_moved: false,
                            is_deref: false,
                            refed_var: None,
                            moved_from: None,
                            type_hint: Box::new(*out.type_hint),
                            var: None,
                        };
                    }
                }
            }
            AstNode::FcCall { params, callee } => {
                let out = self.gen_func_call(expression.clone(), target_type);
                stream += out.clone().stream.as_str();
                return ExprResult {
                    stream,
                    is_ref: false,
                    is_moved: false,
                    is_deref: false,
                    refed_var: None,
                    moved_from: None,
                    type_hint: Box::new(out.type_hint.clone()),
                    var: None,
                };
            }
            AstNode::MemberAccess { base, field } => {
                let out = self.gen_expr(base.clone(), target_type, RefStyle::COPY);
                stream += out.stream.as_str();
                let mut t = self.resolve_type(*out.type_hint.clone());
                if let Type::PTR(v) = t {
                    t = *v;
                }
                let layout = self.get_layout(*out.type_hint.clone());
                if matches!(layout, None) {
                    // ToDo : Error Stream
                    // self.errorout.type_hint.debug()(format!("Not a type {:?}", *out.type_hint), &base);
                    self.consume(CompileError::new(
                        format!("Not a type,  {}", out.type_hint.debug()),
                        None,
                        base.clone().span,
                        ErrLevel::ERROR,
                    ));
                    self.flush();
                    exit(100);
                }
                let mut type_hint: Box<Type> = Box::new(Type::NoType);
                if !layout.as_ref().unwrap().feilds.contains_key(&field.clone()) {
                    // self.error(
                    //     format!(
                    //         "Type {:?} contains no member {field}",
                    //         *out.type_hint.clone()
                    //     ),
                    //     &base,
                    // );
                    self.consume(CompileError::new(
                        format!("Type {} has no field {field}", out.type_hint.debug()),
                        None,
                        base.clone().span,
                        ErrLevel::ERROR,
                    ));
                    self.flush();
                    exit(100);
                }
                let v_field = layout
                    .unwrap()
                    .clone()
                    .feilds
                    .get(&field.clone())
                    .unwrap()
                    .clone();
                if out.var.clone() == None {
                    // self.error(format!("Use of Undeclared variable {}", field), &expr);
                    self.consume(CompileError::new(
                        format!("Use of undeclared symbol {field}"),
                        None,
                        base.clone().span,
                        ErrLevel::ERROR,
                    ));
                    self.flush();
                }
                if let Some(var) = self.lookup_variable(out.var.clone().unwrap().as_str()) {
                    if var.is_ref {
                        stream += format!("->{}", field.clone()).as_str();
                    } else {
                        stream += format!(".{}", field.clone()).as_str();
                    }
                    type_hint = Box::new(v_field.ty);
                } else {
                    // self.error(
                    //     format!("Use of Undeclared variable {}", out.var.unwrap().clone()),
                    //     &expr,
                    // );
                    self.consume(CompileError::new(
                        format!("Use of undeclared symbol {}", out.var.unwrap().clone()),
                        None,
                        base.clone().span,
                        ErrLevel::ERROR,
                    ));
                    self.flush();
                    exit(100);
                }
                return ExprResult {
                    stream,
                    is_ref: false,
                    is_moved: false,
                    is_deref: false,
                    refed_var: None,
                    moved_from: None,
                    type_hint,
                    var: out.var,
                };
            }
            AstNode::ReVal { name, value } => match name.node.clone() {
                AstNode::ListAccess { name: lname, index } => {
                    // println!("Nod: {name:#?}");
                    let out = self.gen_expr(name, Type::Any, RefStyle::COPY);
                    let v = self.gen_expr(value, Type::Any, RefStyle::COPY);
                    stream += &format!("{} = {}", out.stream, v.stream);
                }
                AstNode::MemberAccess { base, field } => {
                    let base_out = self
                        .gen_expr(base.clone(), Type::Any, RefStyle::COPY)
                        .clone();
                    let mut t = self.resolve_type(*base_out.type_hint.clone());
                    if let Type::PTR(v) = t {
                        t = *v;
                    }
                    let layout = self.get_layout(t);
                    // let var = self
                    //     .lookup_variable(base_out.clone().var.unwrap().clone().as_str())
                    //     .unwrap()
                    //     .clone();
                    if matches!(layout, None) {
                        self.consume(CompileError::new(
                            format!("Not a Type. '{}'", base_out.type_hint.debug()),
                            None,
                            base.span,
                            ErrLevel::ERROR,
                        ));
                        self.flush();
                        exit(1);
                    }
                    stream += &base_out.clone().stream;
                    if layout.clone().unwrap().clone().feilds.contains_key(&field) {
                        let v_field = layout.clone().unwrap().feilds.get(&field).unwrap().clone();
                        let out = self.gen_expr(value, Type::Any, RefStyle::COPY).clone();
                        let mut modifier = ".";
                        if base_out.is_ref {
                            modifier = "->";
                        }
                        stream += &format!("{modifier}{} = {}", field, out.stream);
                    }
                }
                AstNode::Token(var, d) => {
                    let val = self.lookup_variable(&var.clone()).unwrap().clone();
                    let out = self.gen_expr(value.clone(), target_type.clone(), RefStyle::COPY);
                    if !self.type_match(target_type, *out.clone().type_hint) {
                        self.consume(CompileError::new(
                            format!(
                                "Type Mismatch. '{}' expected '{}' but got '{}' instead",
                                var.clone(),
                                val.clone().type_hint.debug(),
                                out.type_hint.clone().debug()
                            ),
                            None,
                            value.span,
                            ErrLevel::ERROR,
                        ));
                        self.flush();
                    }
                    stream += &format!("{var} = {}\n", out.stream);
                    return ExprResult {
                        stream,
                        is_ref: v_is_ref,
                        is_moved: v_is_moved,
                        is_deref: v_is_deref,
                        refed_var: None,
                        moved_from: None,
                        type_hint: Box::new(val.type_hint),
                        var: None,
                    };
                }
                _ => {
                    self.consume(CompileError::new(
                        format!("Not an Expression"),
                        None,
                        expression.span,
                        ErrLevel::ERROR,
                    ));
                    self.flush();
                }
            },
            _ => {
                self.consume(CompileError::new(
                    format!("Not a Expression"),
                    None,
                    expr.clone().span,
                    ErrLevel::ERROR,
                ));
                self.flush();
            }
        }
        ExprResult {
            stream,
            is_ref: v_is_ref,
            is_moved: v_is_moved,
            is_deref: v_is_deref,
            refed_var: None,
            moved_from: None,
            type_hint: Box::new(Type::NoType),
            var: None,
        }
    }
    fn gen_func_call(&mut self, expression: Box<Spanned<AstNode>>, target_type: Type) -> FResult {
        let mut stream = String::new();
        let AstNode::FcCall { params, callee } = expression.node.clone() else {
            return FResult {
                stream,
                type_hint: Type::NoType,
            };
        };
        let mut fcname = String::new();
        let mut fargs: Vec<FunctionArg> = Vec::new();
        let mut fret_type = Type::NoType;
        let mut variadic = false;
        match callee.clone().node {
            AstNode::MemberAccess { base, field } => {
                let mut is_f = false;
                if let AstNode::FcCall { params, callee } = base.clone().node {
                    is_f = true;
                }
                let out = self.gen_expr(base.clone(), target_type.clone(), RefStyle::COPY);
                let layout = self.get_layout(*out.clone().type_hint).clone();
                let method = layout
                    .clone()
                    .unwrap()
                    .methods
                    .iter()
                    .find(|m| m.get_name() == field.clone())
                    .cloned();

                if matches!(method, None) {
                    self.consume(CompileError::new(
                        format!(
                            "Type {} has no plugin {}",
                            out.type_hint.debug(),
                            field.clone()
                        ),
                        None,
                        base.clone().span,
                        ErrLevel::ERROR,
                    ));
                    self.flush();
                    exit(1) /* Should never reach here */
                }
                fargs = method.clone().unwrap().args;
                let mut modifier = "";
                let mut gmod = "*";
                let mut gvalmod = "&";
                if out.clone().is_ref {
                    gmod = "*";
                    modifier = "";
                    gvalmod = "";
                } else {
                    gvalmod = "&";
                    modifier = "";
                }
                if is_f {
                    gvalmod = "";
                    gmod = "";
                    modifier = "&";
                }
                let g = self.gb();
                stream += &format!(
                    "({{\n\t{}{gmod} __{} = {gvalmod}{};\n",
                    out.clone().type_hint.to_str(),
                    g.clone(),
                    out.stream
                );
                stream += &format!(
                    "{}_{}({modifier}__{g}",
                    out.clone().type_hint.to_str(),
                    field,
                );
                if !params.clone().is_empty() {
                    stream += ",";
                }
                let mut argsize = fargs.clone().len() as i128;
                #[allow(irrefutable_let_patterns)]
                if let _ = fargs.clone().iter().find(|p| p.name == "self") {
                    if argsize >= 1 {
                        argsize = argsize - 1;
                    }
                }
                #[warn(irrefutable_let_patterns)]
                if argsize as usize != params.clone().len() {
                    self.consume(CompileError::new(
                        format!(
                            "Invalid paramemter count. expected '{}' but got '{}' instead",
                            argsize,
                            params.clone().len()
                        ),
                        None,
                        expression.clone().span,
                        ErrLevel::ERROR,
                    ));
                    self.flush();
                }
                let mut i = 1;
                for arg in params.clone() {
                    let ar = fargs.get(i).clone();
                    let a = self.gen_expr(
                        Box::new(arg.clone()),
                        ar.unwrap().type_hint.clone(),
                        RefStyle::COPY,
                    );
                    if !self.type_match(*a.type_hint.clone(), ar.unwrap().type_hint.clone()) {
                        self.consume(CompileError::new(
                            format!(
                                "mismatched type. got {} instead of {}",
                                a.type_hint.debug(),
                                ar.unwrap().type_hint.debug()
                            ),
                            None,
                            arg.span.clone(),
                            ErrLevel::ERROR,
                        ));
                        self.flush();
                        exit(2);
                    }
                    if *a.type_hint.clone() == Type::NoType {
                        self.consume(CompileError::new(
                            format!("Expression does not return a value"),
                            None,
                            arg.span.clone(),
                            ErrLevel::ERROR,
                        ));
                        self.flush();
                    }
                    stream += &a.stream;
                    if i <= params.len() - 1 {
                        stream += ",";
                    }
                    i += 1;
                }
                stream += &format!(");\n}})");
                return FResult {
                    stream,
                    type_hint: method.unwrap().ty,
                };
            }
            AstNode::BundleAccess { base, field } => {
                if let AstNode::Token(var, i) = base.node.clone() {
                    let mut bundle = self.bundles.clone().iter().find(|b| b.name == var).cloned();
                    if matches!(bundle, None) {
                        // self.error(format!("Could not reslove scope {}", var), &base);
                        self.consume(CompileError::new(
                            format!("Could not resolve scope {var}"),
                            Some("Confirm Bundle path".into()),
                            base.span,
                            ErrLevel::ERROR,
                        ));
                        self.flush();
                        let sf = self.func_table.clone();
                        self.func_table = bundle.clone().unwrap().functions;
                        let out = self.gen_expr(field.clone(), target_type, RefStyle::COPY);
                        stream += &out.stream;
                        exit(100); /* should never reach here */
                    }
                } else if let AstNode::BundleAccess { base: inner, field } = base.node.clone() {
                } else if let AstNode::FcCall { params, callee } = base.node.clone() {
                }
            }
            AstNode::Token(var, _deref) => {
                fcname = var.clone();
                let func = self
                    .func_table
                    .iter()
                    .find(|func| func.get_name() == fcname.clone());
                if matches!(func, None) {
                    // self.error(format!("Use of undeclared symbol {}", var), &expression);
                    println!("{:#?}", self.generics);
                    self.consume(CompileError::new(
                        format!("Use of undeclared symbol {var}"),
                        None,
                        expression.span,
                        ErrLevel::ERROR,
                    ));
                    self.flush();
                    exit(100);
                }
                fargs = func.unwrap().args.clone();
                fret_type = func.unwrap().ty.clone();
                variadic = func.unwrap().variadic;
                stream += format!("{fcname}(").as_str();
            }
            _ => {
                println!("TODO: ERR CALLEE");
                exit(100);
            }
        }
        let parlen = params.len();
        if (fargs.clone().len() != parlen) && !variadic {
            // self.error(
            //     format!(
            //         "Invalid argument count. {} expected {} arguments but got {} instead",
            //         fcname.clone(),
            //         fargs.len(),
            //         parlen
            //     ),
            //     &expression,
            // );
            self.consume(CompileError::new(
                format!("Invalid argument count. {fcname} expected {} parameters but got {parlen} instead", fargs.len()),
                None,
                expression.span,
                ErrLevel::ERROR,
            ));
            self.flush();
        }
        for (index, param) in params.iter().enumerate() {
            let arg = fargs
                .get(index as usize)
                .unwrap_or(
                    &FunctionArg {
                        name: "".into(),
                        type_hint: Type::Any,
                        is_ref: false,
                    }
                    .clone(),
                )
                .clone();

            let expr_code = self.gen_expr(
                Box::new(param.clone()),
                arg.type_hint.clone(),
                RefStyle::COPY,
            );
            if *expr_code.type_hint.clone() == Type::NoType {
                self.consume(CompileError::new(
                    format!("Expression does not return a value"),
                    None,
                    param.span.clone(),
                    ErrLevel::ERROR,
                ));
                self.flush();
            }
            stream += expr_code.stream.as_str();
            if index != params.len() - 1 {
                stream += ",";
            }
            if !self.type_match(arg.type_hint.clone(), *expr_code.type_hint.clone()) {
                self.consume(CompileError::new(
                    format!(
                        "Type Mismatch. '{}' expected '{}' but got '{}' instead",
                        arg.name.clone(),
                        arg.type_hint.clone().debug(),
                        expr_code.type_hint.clone().debug()
                    ),
                    None,
                    param.clone().span,
                    ErrLevel::ERROR,
                ));
                self.flush();
            }
        }
        stream += ")";
        let mut ty = fret_type.clone();
        if let Type::Generic { base, generics } = target_type.clone() {
            let mut hd = String::new();
            let t = self.generics.iter().find(|p| p.name == *base);
            if t.is_some() {
                let ss = self.cur_section.clone();
                self.cur_section = Section::Header;
                hd += &format!("\n\nGENERIC_FN_{fcname}(");
                for (i, g) in generics.iter().enumerate() {
                    hd += &g.to_str();
                    if i != generics.len() - 1 {
                        hd += ",";
                    }
                }
                hd += ");\n";
                self.emit(&hd);
                self.cur_section = ss;
            }
            ty = target_type;
        }
        return FResult {
            stream,
            type_hint: ty,
        };
    }
    fn lookup_variable(&mut self, name: &str) -> Option<&mut Var> {
        self.current_context.look_up_var(name)
    }

    fn emit(&mut self, text: &str) {
        match self.cur_section {
            Section::TEXT => {
                self.text += text;
            }
            Section::FUNC => {
                self.func += text;
            }
            Section::Header => {
                self.header += text;
            }
        }
    }

    fn error(&mut self, err_msg: CompileError) {
        self.has_error = true;
        let span = err_msg.span.clone();
        let source = self.source_code.clone();
        let line_start = source[..span.start].rfind('\n').map_or(0, |i| i + 1);
        let line_end = source[span.start..]
            .find('\n')
            .map(|i| span.start + i)
            .unwrap_or(source.len());
        let line = &source[line_start..line_end];
        let col_start = span.start - line_start;
        let col_end = span.end - line_start;
        let line_number = source[..span.start].chars().filter(|&c| c == '\n').count() + 1;
        eprintln!(
            "{}",
            format!("{} {}", "[Tixie Error] :".red().bold(), err_msg.errmsg)
        );
        let filename = self.inputpath.clone();
        eprintln!(" ---> line : [{filename}:{line_number}]");
        eprintln!("   |\n{: >2} | {}", line_number, line);
        let mut caret_line = String::new();
        for (i, c) in line.chars().enumerate() {
            if i >= col_start && i < col_end {
                caret_line.push('^');
            } else if i < col_start {
                caret_line.push(if c == '\t' { '\t' } else { ' ' });
            }
        }
        eprint!("   | {}", format!("{caret_line}").as_str().yellow().bold());
        if !matches!(err_msg.help, None) {
            eprint!(" help : {}", err_msg.help.unwrap().yellow().bold());
        }
        eprintln!("");
    }

    fn warn(&mut self, err_msg: CompileError) {
        let span = err_msg.span.clone();
        let source = self.source_code.clone();
        let line_start = source[..span.start].rfind('\n').map_or(0, |i| i + 1);
        let line_end = source[span.start..]
            .find('\n')
            .map(|i| span.start + i)
            .unwrap_or(source.len());
        let line = &source[line_start..line_end];
        let col_start = span.start - line_start;
        let col_end = span.end - line_start;
        let line_number = source[..span.start].chars().filter(|&c| c == '\n').count() + 1;
        eprintln!(
            "{}",
            format!("[Tixie Warning]: {}", err_msg.errmsg)
                .yellow()
                .bold()
        );
        let filename = self.inputpath.clone();
        eprintln!(" ---> line : [{filename}:{line_number}]");
        eprintln!("   |\n{: >2} | {}", line_number, line);
        let mut caret_line = String::new();
        for (i, c) in line.chars().enumerate() {
            if i >= col_start && i < col_end {
                caret_line.push('^');
            } else if i < col_start {
                caret_line.push(if c == '\t' { '\t' } else { ' ' });
            }
        }
        eprint!("   | {}", format!("{caret_line}").as_str().yellow().bold());
        if !matches!(err_msg.help, None) {
            eprint!(" help : {}", err_msg.help.unwrap().blue())
        }
        eprintln!("");
    }

    fn verifyType(&mut self, type_hint: Type) -> Option<Type> {
        if let Type::PTR(_) = type_hint {
            return Some(type_hint);
        }
        if let Type::BundledType { bundle, ty } = type_hint {
            let bd = self.bundles.iter().find(|b| b.name == bundle).cloned();
            if matches!(bd, None) {
                return None;
            }
            let sb = self.bundles.clone();
            let st = self.types.clone();
            let sc = self.current_context.clone();
            let sv = self.var_table.clone();
            self.bundles = bd.clone().unwrap().bundles.clone();
            self.types = bd.clone().unwrap().types.clone();
            self.var_table = bd.unwrap().vars;
            let g = self.verifyType(*ty);
            self.bundles = sb.clone();
            self.types = st.clone();
            self.current_context = sc.clone();
            self.var_table = sv.clone();
            return g;
        }
        self.types.verify(type_hint)
    }

    fn get_layout(&mut self, type_hint: Type) -> Option<BlockLayout> {
        if let Type::BundledType { bundle, ty } = type_hint {
            let bd = self.bundles.iter().find(|b| b.name == bundle).cloned();
            if matches!(bd, None) {
                return None;
            }
            let sb = self.bundles.clone();
            let st = self.types.clone();
            let sc = self.current_context.clone();
            let sv = self.var_table.clone();
            self.bundles = bd.clone().unwrap().bundles.clone();
            self.types = bd.clone().unwrap().types.clone();
            self.var_table = bd.unwrap().vars;
            let g = self.get_layout(*ty);
            self.bundles = sb.clone();
            self.types = st.clone();
            self.current_context = sc.clone();
            self.var_table = sv.clone();
            return g;
        } else if let Type::PTR(ty) = type_hint {
            return self.get_layout(*ty);
        }
        self.types.getLayout(type_hint)
    }

    fn consume(&mut self, err: CompileError) {
        self.errorbox.push(err);
    }
    fn resolve_type(&mut self, t: Type) -> Type {
        match t.clone() {
            Type::BundledType { bundle, ty } => {
                let bndl = self
                    .bundles
                    .clone()
                    .iter()
                    .find(|b| b.name == bundle)
                    .cloned();
                let sb = self.bundles.clone();
                if !bndl.is_some() {
                    return *ty;
                }
                self.bundles = bndl.clone().unwrap().bundles.clone();
                let t2 = self.resolve_type(*ty);
                self.bundles = sb.clone();
                t2
            }
            _ => t,
        }
    }
    fn type_match(&mut self, ty1: Type, ty2: Type) -> bool {
        let a = self.resolve_type(ty1);
        let b = self.resolve_type(ty2);
        match (a, b) {
            (
                Type::BundledType {
                    bundle: b1,
                    ty: ty_1,
                },
                Type::BundledType {
                    bundle: b2,
                    ty: ty_2,
                },
            ) => {
                let l1 = self.get_layout(*ty_1.clone()).clone();
                let l2 = self.get_layout(*ty_2.clone()).clone();
                l1.unwrap().file == l2.unwrap().file && self.type_match(*ty_1, *ty_2)
            }
            (Type::Any, _) => true,
            (_, Type::BundledType { bundle, ty }) | (Type::BundledType { bundle, ty }, _) => false,
            (Type::Custom(c1), Type::Custom(c2)) => c1 == c2,
            (Type::INT, other) => is_int(other),
            (other, Type::INT) => is_int(other),
            (Type::STR, Type::STR) => true,
            (Type::STR, other) => false,
            (other, Type::STR) => false,
            (Type::list(T, s), Type::list(T2, s2)) => self.type_match(*T, *T2) && s == s2,
            (Type::CHAR, Type::CHAR) => true,
            (Type::NoType, Type::NoType) => true,
            (Type::PTR(v), Type::PTR(c)) => self.type_match(*v, *c),
            (
                Type::Generic {
                    base: b1,
                    generics: g1,
                },
                Type::Generic {
                    base: b2,
                    generics: g2,
                },
            ) => self.type_match(*b1, *b2) && g1 == g2,
            (int1, int2) => is_int(int1) && is_int(int2),
            _ => false,
        }
    }

    fn flush(&mut self) {
        let mut shld_err = false;
        for err in self.errorbox.clone() {
            match err.level {
                ErrLevel::WARNING => {
                    self.warn(err);
                }
                ErrLevel::ERROR => {
                    self.error(err);
                    shld_err = true;
                }
                ErrLevel::INFO => self.warn(err),
            }
        }
        if !self.errorbox.is_empty() && shld_err {
            exit(1);
        }
    }

    fn register_plugin(&mut self, ty: Type, plugin: Function) {
        if let Type::BundledType { bundle, ty } = ty {
            let bd = self.bundles.iter().find(|b| b.name == bundle).cloned();
            let sb = self.bundles.clone();
            let st = self.types.clone();
            let sc = self.current_context.clone();
            let sv = self.var_table.clone();
            self.bundles = bd.clone().unwrap().bundles.clone();
            self.types = bd.clone().unwrap().types.clone();
            self.var_table = bd.unwrap().vars;
            self.register_plugin(*ty, plugin);
            self.bundles = sb.clone();
            self.types = st.clone();
            self.current_context = sc.clone();
            self.var_table = sv.clone();
            return;
        }
        self.types.register_plugin(ty, plugin);
    }
    fn gb(&mut self) -> String {
        let mut name: String = String::from_str("gbval").unwrap();
        name += &format!("{}", self.immediate_counter);
        self.immediate_counter += 1;
        name.into()
    }

    fn check_overflow(&mut self, value: i128, target_type: Type, span: Span) {
        match target_type.clone() {
            Type::U8 => {
                if value < 0 || value > 255 {
                    let warp = value as u8;
                    self.consume(CompileError::new(
                        format!("u8 overflow. value {value} warped to {warp}"),
                        Some("Use from range 0..255 for type u8".into()),
                        span,
                        ErrLevel::WARNING,
                    ));
                }
            }
            Type::U16 => {
                if value < u16::MIN as i128 || value > u16::MAX as i128 {
                    let warp = value as u16;
                    self.consume(CompileError::new(
                        format!("u16 overflow. value {value} warped to {warp}"),
                        Some(format!(
                            "Use from range {}..{} for type u16",
                            u16::MIN,
                            u16::MAX
                        )),
                        span,
                        ErrLevel::WARNING,
                    ));
                }
            }
            Type::U32 => {
                if value < u32::MIN as i128 || value > u32::MAX as i128 {
                    let warp = value as u32;
                    self.consume(CompileError::new(
                        format!("u16 overflow. value {value} warped to {warp}"),
                        Some(format!(
                            "Use from range {}..{} for type u32",
                            u32::MIN,
                            u32::MAX
                        )),
                        span,
                        ErrLevel::WARNING,
                    ));
                }
            }
            Type::U64 => {
                if value < u64::MIN as i128 || value > u64::MAX as i128 {
                    let warp = value as u64;
                    self.consume(CompileError::new(
                        format!("u16 overflow. value {value} warped to {warp}"),
                        Some(format!(
                            "Use from range {}..{} for type u64",
                            u64::MIN,
                            u64::MAX
                        )),
                        span,
                        ErrLevel::WARNING,
                    ));
                }
            }
            Type::I8 => {
                if value < i8::MIN as i128 || value > i8::MAX as i128 {
                    let warp = value as i8;
                    self.consume(CompileError::new(
                        format!("u16 overflow. value {value} warped to {warp}"),
                        Some(format!(
                            "Use from range {}..{} for type i8",
                            i8::MIN,
                            i8::MAX
                        )),
                        span,
                        ErrLevel::WARNING,
                    ));
                }
            }
            Type::I16 => {
                if value < i16::MIN as i128 || value > i16::MAX as i128 {
                    let warp = value as i16;
                    self.consume(CompileError::new(
                        format!("u16 overflow. value {value} warped to {warp}"),
                        Some(format!(
                            "Use from range {}..{} for type i16",
                            i16::MIN,
                            i16::MAX
                        )),
                        span,
                        ErrLevel::WARNING,
                    ));
                }
            }
            Type::I32 => {
                if value < i32::MIN as i128 || value > i32::MAX as i128 {
                    let warp = value as i32;
                    self.consume(CompileError::new(
                        format!("u16 overflow. value {value} warped to {warp}"),
                        Some(format!(
                            "Use from range {}..{} for type i32",
                            i32::MIN,
                            i32::MAX
                        )),
                        span,
                        ErrLevel::WARNING,
                    ));
                }
            }
            Type::I64 => {
                if value < i64::MIN as i128 || value > i64::MAX as i128 {
                    let warp = value as i64;
                    self.consume(CompileError::new(
                        format!("u16 overflow. value {value} warped to {warp}"),
                        Some(format!(
                            "Use from range {}..{} for type i64",
                            i64::MIN,
                            i64::MAX
                        )),
                        span,
                        ErrLevel::WARNING,
                    ));
                }
            }
            Type::INT => {
                if value < i64::MIN as i128 || value > i64::MAX as i128 {
                    let warp = value as i64;
                    self.consume(CompileError::new(
                        format!("u16 overflow. value {value} warped to {warp}"),
                        Some(format!(
                            "Use from range {}..{} for type int a.k.a i64",
                            i64::MIN,
                            i64::MAX
                        )),
                        span,
                        ErrLevel::WARNING,
                    ));
                }
            }
            _ => {}
        }
    }

    fn set_ref(&mut self, val: Var) {
        self.current_context.set_ref(val);
    }

    fn is_castable(&mut self, ty: Type, type_hint: Type) -> bool {
        let a = self.resolve_type(ty);
        let b = self.resolve_type(type_hint);
        match (a, b) {
            (Type::PTR(v), Type::PTR(f)) => true,
            (Type::STR, Type::PTR(v)) => true,
            (Type::PTR(v), Type::STR) => true,
            (int1, int2) => is_int(int1.clone()) && is_int(int2.clone()) || int1 == int2,
        }
    }

    fn is_iterable(&mut self, clone: Type) -> bool {
        match clone.clone() {
            Type::PTR(v) => true,
            Type::list(_, _) => true,
            Type::STR => true,
            _ => false,
        }
    }
}

fn is_builtin(clone: Type) -> bool {
    match clone {
        Type::Custom(_) => false,
        Type::BundledType { bundle, ty } => false,
        _ => true,
    }
}

fn is_int(target_type: Type) -> bool {
    use crate::backend::ttype::Type::*;
    matches!(
        target_type,
        INT | U8 | U64 | U32 | U16 | I8 | I16 | I32 | I64 | CHAR
    )
}
